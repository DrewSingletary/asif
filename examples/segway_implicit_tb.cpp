#include <iostream>
#include <fstream>
#include <iomanip>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "asif++.h"
#include "customTimer.h"

using namespace std;

const uint32_t nx = 4;
const uint32_t nu = 1;
const uint32_t npSS = 4;
const uint32_t npBTSS = 4;

const double lb[nu] = {-20.0};
const double ub[nu] = {20.0};
const double xBound[nx] = {3.0,3.0,M_PI/6,M_PI};

const double K[nx] = {44.7214, 44.6528, 150.1612, 37.6492};
const double Pv = 0.05;

ASIF::ASIFimplicitTB *asif;

void safetySet(const double *x, double *h, double *Dh)
{
	for(uint32_t i = 0; i<npSS*nx; i++)
	{
		Dh[i] = 0.0;
	}
	for(uint32_t i = 0; i<nx; i++)
	{
		h[i] = (xBound[i]*xBound[i])-(x[i]*x[i]);
		Dh[i*(nx+1)] = -2.0*x[i];
	}
}

void backupSet(const double *x, double *h, double *Dh, double*DDh)
{
	for(uint32_t i = 0; i<nx*nx; i++)
	{
		DDh[i] = 0.0;
	}

	h[0] = Pv*Pv;
	for(uint32_t i = 0; i<nx; i++)
	{
		h[0] -= (x[i]/xBound[i])*(x[i]/xBound[i]);
		Dh[i] = -2.0*x[i]/(xBound[i]*xBound[i]);
		DDh[i*(nx+1)] = -2.0/(xBound[i]*xBound[i]);
	}
}

void backupController(const double *x, double *u, double *Du)
{
	double xTemp[nx] = {0.,0.,-0.1383244254,0.};
	for(uint32_t i=0; i<nx; i++)
	{
		xTemp[i]+=x[i];
	}
	ASIF::matrixVectorMultiply(K,nu,nx,
	                           xTemp,nx,
	                           u);
	memcpy(Du,K,sizeof(K));
}

void dynamics(const double X[4], double f[4], double g[4])
{
  double Fric;
  double f_tmp;
  double b_f_tmp;
  double c_f_tmp;
  double d_f_tmp;
  double e_f_tmp;
  double f_f_tmp;

  /* 2.595498 */
  Fric = 0.0*2.595498 * tanh(X[1] / 0.001);
  f[0] = X[1];
  f_tmp = X[3] * X[3];
  b_f_tmp = sin(X[2]);
  c_f_tmp = sin(2.0 * X[2]);
  d_f_tmp = cos(2.0 * X[2]);
  e_f_tmp = cos(X[2]);
  f_f_tmp = 1.0 / ((14.553176960783997 + -2.0831375273848773 * d_f_tmp) +
                   -0.59146430898882 * c_f_tmp);
  f[1] = 0.0975 * ((((((((((-23.195670626755415 * Fric + -0.0043160179477503974 *
    Fric * 44.798) + -0.22270033964034344 * Fric * 44.798) + 44.798 *
    (((-1.3347669149041519 * Fric + -0.2693850964936445 * f_tmp) +
      -0.0022454764220255392 * f_tmp) + -0.11586336477125109 * f_tmp) * 0.195 *
    e_f_tmp) + 59.510408935182809 * d_f_tmp) + -0.185817500742 * Fric * 44.798 *
                        0.195 * b_f_tmp) + 86.686408318784913 * f_tmp * 0.195 *
                       b_f_tmp) + 0.72258001100852454 * f_tmp * 0.195 * b_f_tmp)
                     + 37.284092841364554 * f_tmp * 0.195 * b_f_tmp) +
                    4.1423245261005457 * c_f_tmp) + -213.73800805067131 *
                   c_f_tmp) * f_f_tmp;
  f[2] = X[3];
  f[3] = f_f_tmp * ((((((((((8.0 * Fric * 0.055936595310797 + 4.0 * Fric *
    44.798 * 0.038025) + 8.0 * Fric * 2.485 * 0.038025) + 89.596 *
    (0.333691728726038 * Fric * 0.195 + -0.45669752988922296) * e_f_tmp) +
    15.554616935932147 * f_tmp * 0.038025 * d_f_tmp) + 16.405863695295427 *
    b_f_tmp) + 0.092908750371 * Fric * 44.798 * 0.195 * b_f_tmp) +
                       249.80488266222164 * b_f_tmp) + 27.713966400983114 *
                      b_f_tmp) + 1.0827059060875992 * f_tmp * 0.038025 * c_f_tmp)
                    + -55.866072832711595 * f_tmp * 0.038025 * c_f_tmp);
  g[0] = 0.0;
  Fric = 1.4575004011882324 * e_f_tmp;
  f_tmp = 0.20290365220710288 * b_f_tmp;
  g[1] = 0.551244194154502 * ((4.1706936767483551 + Fric) + f_tmp) * (1.0 /
    (((8.3593271361634187 + -2.1243074194638587 * (e_f_tmp * e_f_tmp)) +
      -0.04116989207898096 * (b_f_tmp * b_f_tmp)) + -0.29573215449441 * c_f_tmp));
  g[2] = 0.0;
  g[3] = -5.65378660671284 * ((2.0043013906215941 + Fric) + f_tmp) * f_f_tmp;
}

void dynamicsGradients(const double x[4], double Df[16], double Dg[16])
{
  double t2_tmp;
  double t3_tmp;
  double t4;
  double t5;
  double t6;
  double t7;
  double t9;
  double t25;
  double t26;
  double t23;
  double Df_tmp;
  double b_Df_tmp;
  double c_Df_tmp;
  double dv0[16];

  /* JFFUN */
  /*     JF = JFFUN(IN1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
  /*     29-Sep-2019 19:11:35 */
  t2_tmp = cos(x[2]);
  t3_tmp = sin(x[2]);
  t4 = x[2] * 2.0;
  t5 = x[3] * x[3];
  t6 = cos(t4);
  t7 = sin(t4);
  t9 = tanh(x[1] * 1000.0);
  t4 = t9 * t9;
  t25 = t9 * 15.13175750513302 - 40.918271887954823;
  t26 = t5 * 3.3849959169972448 + t9 * 30.26351501026604;
  t23 = 1.0 / ((t6 * 2.0831375273848769 + t7 * 0.59146430898882) -
               14.553176960784);
  Df[0] = 0.0;
  Df[1] = 0.0;
  Df[2] = 0.0;
  Df[3] = 0.0;
  Df[4] = 1.0;
  Df_tmp = t3_tmp * (t4 * 1000.0 - 1000.0);
  Df[5] = -t23 * (((t4 * 8443.5211353581435 + Df_tmp * 0.41077609832706019) +
                   t2_tmp * (t4 * 30263.515010266041 - 30263.515010266041) *
                   0.0975) - 8443.5211353581435);
  Df[6] = 0.0;
  Df[7] = t23 * (((t4 * 20808.641003022261 + Df_tmp * 2.1065440939849238) +
                  t2_tmp * (t4 * 15131.75750513302 - 15131.75750513302)) -
                 20808.641003022261);
  Df[8] = 0.0;
  Df_tmp = t2_tmp * t9;
  b_Df_tmp = t3_tmp * t9;
  c_Df_tmp = (t6 * 1.18292861797764 + -(t7 * 4.1662750547697547)) * (t23 * t23);
  Df[9] = t23 * ((((t6 * 40.8711582872913 + t7 * 11.604529742360651) - t2_tmp *
                   t5 * 2.3707272057666411) + Df_tmp * 0.41077609832706019) -
                 t3_tmp * t26 * 0.0975) - c_Df_tmp * (((((t6 *
    -5.8022648711803244 + t7 * 20.435579143645651) + t9 * 8.443521135358143) -
    t3_tmp * t5 * 2.3707272057666411) + b_Df_tmp * 0.41077609832706019) + t2_tmp
    * t26 * 0.0975);
  Df[10] = 0.0;
  t26 = t5 * t6;
  t4 = t5 * t7;
  Df[11] = t23 * ((((t2_tmp * -293.92471275850022 - Df_tmp * 2.1065440939849238)
                    + t26 * 4.1662750547697547) + t4 * 1.18292861797764) +
                  t3_tmp * t25) + c_Df_tmp * (((((t3_tmp * 293.92471275850022 +
    t9 * 20.808641003022259) + t26 * 0.59146430898881985) + b_Df_tmp *
    2.1065440939849238) - t4 * 2.0831375273848769) + t2_tmp * t25);
  Df[12] = 0.0;
  Df[13] = t23 * (t2_tmp * x[3] * 0.6600742038144628 - t3_tmp * x[3] *
                  4.7414544115332831);
  Df[14] = 1.0;
  Df[15] = -t23 * (t6 * x[3] * 1.18292861797764 - t7 * x[3] * 4.1662750547697547);

  /* JGFUN */
  /*     JG = JGFUN(IN1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.3. */
  /*     29-Sep-2019 19:11:35 */
  t4 = x[2] * 2.0;
  t5 = cos(t4);
  t7 = sin(t4);
  t4 = (t5 * 2.0831375273848769 + t7 * 0.59146430898882) - 14.553176960784;
  t26 = ((t2_tmp * t2_tmp * 2.1243074194638591 + t7 * 0.29573215449441) + t3_tmp
         * t3_tmp * 0.04116989207898096) - 8.3593271361634187;
  memset(&dv0[0], 0, 9U * sizeof(double));
  dv0[9] = -(t2_tmp * 0.1118494602519098 - t3_tmp * 0.80343863413287053) / t26 +
    1.0 / (t26 * t26) * (t5 * 0.59146430898882 - t2_tmp * t3_tmp *
    4.1662750547697547) * ((t2_tmp * 0.80343863413287053 + t3_tmp *
    0.1118494602519098) + 2.2990706749044238);
  dv0[10] = 0.0;
  dv0[11] = (t2_tmp * 1.1471739513016379 - t3_tmp * 8.24039624751662) / t4 - 1.0
    / (t4 * t4) * (t5 * 1.18292861797764 - t7 * 4.1662750547697547) * ((t2_tmp *
    8.24039624751662 + t3_tmp * 1.1471739513016379) + 11.33189235811229);
  dv0[12] = 0.0;
  dv0[13] = 0.0;
  dv0[14] = 0.0;
  dv0[15] = 0.0;
  memcpy(&Dg[0], &dv0[0], sizeof(double) << 4);
}

int main()
{

	// ofstream myfile;
	// myfile.open("log.csv", ofstream::out | ofstream::trunc);
	// myfile << "tNow" <<','<< "x[0]" <<','<<  "x[1]" <<','<< "x[2]" <<','<<  "x[3]" <<','<<  "uDes" <<','<<  "uAct" <<','<< "TTSmax" <<','<< "TTS" <<','<< "orhto" <<','<<  "hMinSS" << endl;
	// myfile << std::fixed;
	// myfile << std::setprecision(10);

	ASIF::ASIFimplicitTB::Options opts;
	opts.backTrajHorizon = 3.0;
	opts.backTrajDt = 0.01;
	opts.relaxCost = 10;
	opts.relaxSafeLb = 2.0;
	opts.relaxTTS = 30.0;
	opts.relaxMinOrtho = 60.0;
	opts.backTrajMinOrtho = 0.001;

	asif = new ASIF::ASIFimplicitTB(nx,nu,npSS,npBTSS,
	                                safetySet,backupSet,dynamics,dynamicsGradients,backupController);

	asif->initialize(lb,ub,opts);

	const double tEnd = 10.99;
	const double dt = 0.001;
	double xNow[nx] = {0.0,0.0,0.0,0.0};
	double uDesNow[nu] = {0.0};
	double uActNow[nu] = {0.0};
	double tNow = 0.0;
	double relax;
	// double trash[nx];
	int32_t rc = 1;

	bool optionsUpdated = false;
	CustomTimer timer;


	while(tNow<tEnd)
	{
		if(!optionsUpdated && tNow>(tEnd/2))
		{
			opts.backTrajHorizon = 6.0;
			optionsUpdated = true;
			asif->updateOptions(opts);
		}
		
		tic(&timer);
		rc = asif->filter(xNow,uDesNow,uActNow,relax);
		// backupController(xNow,uActNow,trash);
		toc(&timer);

		// Integrate
		double fCl[nx] = {0.0};
		double f[nx];
		double g[nx];
		dynamics(xNow, f, g);
		for(uint32_t i = 0; i<nx; i++)
		{
			fCl[i]+=f[i];
			for(uint32_t k = 0; k<nu; k++)
			{
				fCl[i]+= g[i+k*nx]*uActNow[k];
			}
		}

		for(uint32_t i = 0; i<nx; i++)
		{
			xNow[i] += dt*fCl[i];
		}
		tNow += dt;

		// Print data
		uint32_t printAcc = 3U;
		cout << std::fixed;
		cout << std::setprecision(3);
		cout << "t: " << tNow ;
		cout << std::scientific;
		cout << std::setprecision(printAcc);
		for(uint32_t i = 0; i<nx; i++)
		{
			cout << " | x" << i << ":";
			cout << std::setw(printAcc+7) << xNow[i];
		}
		cout <<  " | uDes:";
		cout << std::setw(printAcc+7) << uDesNow[0];
		cout << " | uAct:";
		cout << std::setw(printAcc+7) << uActNow[0];
		cout << " | relax:";
		cout << std::setw(printAcc+7) << relax;
		cout << " | TTS:";
		cout << std::setw(printAcc+7) << asif->TTS_;
		cout << " | BTorthoBS:";
		cout << std::setw(printAcc+7) << asif->BTorthoBS_;
		// cout << " | hMinIdx:";
		// if(rc>0)
		// 	cout << std::setw(printAcc+7) << asif->backTrajCritIdx_[0];
		// else
		// 	cout << std::setw(printAcc+7) << 0;
		cout << " | dt(us):";
		cout << std::fixed;
		cout << std::setprecision(1);
		cout << timer.dt*1e6;
		cout << " | rc:";
		cout << rc;		
		cout << endl;

		// myfile << tNow <<',';
		// for(uint32_t i = 0; i<nx; i++)
		// {
		// 	myfile << xNow[i] <<',';
		// }
		// myfile << uDesNow[0] <<','<<  uActNow[0] <<','<<  opts.backTrajHorizon <<','<< asif->TTS_ <<','<<  asif->BTorthoBS_ <<',';
		// if(rc>0)
		// 	myfile << asif->backTrajCritIdx_[0];
		// else
		// 	myfile << 0;
		// myfile <<','<< rc << endl;
	}

	// myfile.close();
	cout << "Finished" << endl;

	return 0;
}

